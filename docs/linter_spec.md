# MDX Linter Specification

## Overview

The MDX Linter is a critical component that sits between the parser and transformer, responsible for cleaning and optimizing parsed MDX structures before they are converted to IR. The linter addresses the "spaghetti mess" output commonly generated by Oracle Essbase/Necto SSAS cubes, transforming verbose and redundant MDX into clean, normalized structures.

## Purpose and Goals

### Primary Goals
1. **Clean Redundant Structures** - Remove unnecessary parentheses, duplicate member specifications, and verbose nesting
2. **Optimize Performance** - Simplify complex expressions and eliminate redundant operations
3. **Normalize Syntax** - Standardize function calls, member references, and set operations
4. **Preserve Semantics** - Ensure all optimizations maintain query correctness and intent
5. **Improve Readability** - Make MDX more understandable for downstream transformation

### Secondary Goals
- Generate optimization reports showing what was cleaned
- Provide configurable optimization levels (conservative, moderate, aggressive)
- Support custom optimization rules for specific MDX patterns
- Enable selective optimization (e.g., only clean parentheses, not function calls)

## Target Patterns for Optimization

### 1. Redundant Parentheses and Nesting

**Problem**: Necto often generates excessive parentheses and nested structures
```mdx
-- Before (Necto output)
SELECT 
    (((([Measures].[Sales Amount]))) ON COLUMNS,
    (((NON EMPTY (([Product].[Category].Members))))) ON ROWS
FROM [Sales Cube]
```

**After (Linted)**
```mdx
SELECT 
    [Measures].[Sales Amount] ON COLUMNS,
    NON EMPTY [Product].[Category].Members ON ROWS
FROM [Sales Cube]
```

### 2. Verbose Function Call Chains

**Problem**: Unnecessarily complex function compositions
```mdx
-- Before
CROSSJOIN(
    CROSSJOIN(
        [Time].[Year].Members,
        [Geography].[Country].Members
    ),
    [Product].[Category].Members
)
```

**After**
```mdx
[Time].[Year].Members * [Geography].[Country].Members * [Product].[Category].Members
```

### 3. Duplicate Member Specifications

**Problem**: Same members referenced multiple times in different ways
```mdx
-- Before
SELECT 
    {[Product].[Category].[Electronics], [Product].[Category].[Electronics]} ON COLUMNS
```

**After**
```mdx
SELECT 
    [Product].[Category].[Electronics] ON COLUMNS
```

### 4. Unnecessary CrossJoins

**Problem**: CrossJoins that can be simplified to tuple operations
```mdx
-- Before
CROSSJOIN({[Time].[2023]}, {[Geography].[USA]})
```

**After**
```mdx
([Time].[2023], [Geography].[USA])
```

### 5. Complex Calculated Members

**Problem**: Verbose calculated member definitions with unclear dependencies
```mdx
-- Before
WITH MEMBER [Measures].[Profit Margin] AS 
    IIF(
        ([Measures].[Sales Amount]) <> 0,
        (([Measures].[Sales Amount]) - ([Measures].[Cost Amount])) / ([Measures].[Sales Amount]),
        NULL
    )
```

**After**
```mdx
WITH MEMBER [Measures].[Profit Margin] AS 
    IIF([Measures].[Sales Amount] <> 0,
        ([Measures].[Sales Amount] - [Measures].[Cost Amount]) / [Measures].[Sales Amount],
        NULL)
```

## Linter Architecture

### Core Components

1. **LintRule Interface** - Base class for all optimization rules
2. **ParenthesesCleaner** - Removes redundant parentheses
3. **FunctionOptimizer** - Simplifies function call patterns
4. **SetNormalizer** - Optimizes set operations and member selections
5. **CrossJoinOptimizer** - Converts complex CrossJoins to simpler forms
6. **DuplicateRemover** - Eliminates duplicate references
7. **CalculatedMemberOptimizer** - Cleans calculated member expressions
8. **LintReport** - Tracks and reports optimizations performed

### Optimization Levels

1. **Conservative** (Default)
   - Remove obvious redundant parentheses
   - Eliminate exact duplicates
   - Basic function call cleanup

2. **Moderate**
   - All conservative optimizations
   - Simplify common CrossJoin patterns
   - Normalize member reference formats
   - Clean calculated member expressions

3. **Aggressive**
   - All moderate optimizations
   - Advanced function composition optimization
   - Complex set operation simplification
   - May change query structure significantly

### Configuration Options

```python
@dataclass
class LinterConfig:
    """Configuration for MDX linter behavior."""
    
    # Optimization level
    optimization_level: OptimizationLevel = OptimizationLevel.CONSERVATIVE
    
    # Rule-specific settings
    remove_redundant_parentheses: bool = True
    optimize_crossjoins: bool = True
    remove_duplicates: bool = True
    normalize_member_references: bool = True
    optimize_calculated_members: bool = False  # Only in moderate+
    
    # Advanced settings
    max_crossjoin_depth: int = 3  # Convert nested CrossJoins to tuples
    preserve_original_structure: bool = False  # Keep original for comparison
    generate_optimization_report: bool = True
    
    # Custom rules
    custom_rules: List[LintRule] = field(default_factory=list)
    disabled_rules: List[str] = field(default_factory=list)
```

## Implementation Details

### Rule Engine

Each optimization rule implements the `LintRule` interface:

```python
class LintRule(ABC):
    """Base class for linting rules."""
    
    @abstractmethod
    def name(self) -> str:
        """Return rule name for reporting."""
        pass
    
    @abstractmethod
    def description(self) -> str:
        """Return rule description."""
        pass
    
    @abstractmethod
    def can_apply(self, node: Tree) -> bool:
        """Check if rule can be applied to this node."""
        pass
    
    @abstractmethod
    def apply(self, node: Tree) -> Tuple[Tree, List[LintAction]]:
        """Apply rule and return modified tree plus actions taken."""
        pass
    
    @property
    def optimization_level(self) -> OptimizationLevel:
        """Minimum optimization level required for this rule."""
        return OptimizationLevel.CONSERVATIVE
```

### Processing Pipeline

```python
class MDXLinter:
    """Main linter class that orchestrates optimization rules."""
    
    def __init__(self, config: LinterConfig = None):
        self.config = config or LinterConfig()
        self.rules = self._load_rules()
        self.report = LintReport()
    
    def lint(self, tree: Tree) -> Tuple[Tree, LintReport]:
        """Apply all applicable rules to the parse tree."""
        current_tree = tree
        
        for rule in self.rules:
            if self._should_apply_rule(rule):
                current_tree, actions = rule.apply(current_tree)
                self.report.add_actions(rule.name(), actions)
        
        return current_tree, self.report
```

### Specific Rule Implementations

#### 1. ParenthesesCleaner

```python
class ParenthesesCleaner(LintRule):
    """Removes redundant parentheses from expressions."""
    
    def apply(self, node: Tree) -> Tuple[Tree, List[LintAction]]:
        actions = []
        
        # Find nested parentheses patterns
        # Remove single-child parentheses groups
        # Keep necessary parentheses for operator precedence
        
        return optimized_tree, actions
```

#### 2. CrossJoinOptimizer

```python
class CrossJoinOptimizer(LintRule):
    """Optimizes CrossJoin operations."""
    
    def apply(self, node: Tree) -> Tuple[Tree, List[LintAction]]:
        actions = []
        
        # Pattern: CROSSJOIN({A}, {B}) -> (A, B)
        # Pattern: CROSSJOIN(CROSSJOIN(A, B), C) -> A * B * C
        # Pattern: Multiple nested CrossJoins -> Flattened multiplication
        
        return optimized_tree, actions
```

#### 3. FunctionOptimizer

```python
class FunctionOptimizer(LintRule):
    """Optimizes function call patterns."""
    
    def apply(self, node: Tree) -> Tuple[Tree, List[LintAction]]:
        actions = []
        
        # IIF(condition, value, value) -> value
        # UNION(set, {}) -> set
        # FILTER(set, TRUE) -> set
        # Members functions that can be simplified
        
        return optimized_tree, actions
```

### Testing Strategy

#### Unit Tests (per rule)
- Test each rule with specific patterns it should optimize
- Verify edge cases and boundary conditions
- Ensure rules don't break valid MDX
- Test rule interactions and conflicts

#### Integration Tests
- Test complete linting pipeline with real Necto queries
- Verify optimization levels work correctly
- Test configuration options
- Performance benchmarks with large queries

#### Regression Tests
- Ensure optimized queries produce same results as originals
- Test against known problematic patterns from production
- Validate with Power BI/SSAS for DAX conversion compatibility

## Error Handling and Safety

### Conservative Approach
- If a rule cannot safely determine if an optimization is valid, skip it
- Always preserve query semantics over optimization
- Generate warnings for potentially unsafe optimizations

### Validation
- Parse optimized MDX to ensure it's still valid
- Compare AST structure before/after for semantic equivalence
- Option to validate against source data for result equality

### Rollback Capability
- Keep original tree structure for comparison
- Allow selective rule application/removal
- Generate diff reports showing all changes made

## Performance Considerations

### Optimization Goals
- Process 1000-line MDX query in < 500ms
- Memory usage < 100MB for large queries
- Minimize tree traversals (single-pass where possible)

### Caching Strategy
- Cache rule applicability checks
- Memoize pattern matching results
- Reuse optimized subtrees when possible

## Integration Points

### With Parser
- Accepts Lark Tree objects from MDX parser
- Preserves source location information for error reporting
- Maintains comment and whitespace information when requested

### With Transformer
- Outputs cleaned Tree objects to MDX transformer
- Provides optimization report for transformer context
- Allows transformer to skip certain normalizations already done

### With Configuration
- Integrates with global package configuration
- Supports environment-specific optimization profiles
- Allows runtime rule customization

## Future Extensions

### Rule Marketplace
- Plugin system for custom optimization rules
- Community-contributed rules for specific MDX patterns
- Organization-specific rule sharing

### AI-Powered Optimization
- Machine learning to identify optimization opportunities
- Pattern recognition for new redundancy types
- Adaptive optimization based on query performance feedback

### Integration with BI Tools
- Direct integration with Power BI for optimization validation
- SSAS compatibility checking
- Real-time optimization suggestions in IDEs

## Success Metrics

### Quantitative
- 50%+ reduction in average MDX query length
- 90%+ preservation of query semantics
- < 500ms processing time for typical Necto queries
- 95%+ test coverage for all rules

### Qualitative
- Significantly improved readability of optimized MDX
- Clear optimization reports showing value provided
- Positive feedback from users on query clarity
- Successful integration with existing transformation pipeline