# MDX Language Specification - Major Components for Parser Implementation

## Overview

This document outlines the major components of the MDX (Multidimensional Expressions) language that need to be implemented for parsing MDX queries from Oracle Essbase (particularly those generated by Necto SSAS cubes). The specification follows BNF (Backus-Naur Form) notation.

## 1. Core Query Structure

### 1.1 SELECT Statement

The fundamental MDX query structure follows this pattern:

```bnf
<mdx_statement> ::= <select_statement>

<select_statement> ::= [<with_section>]
                      SELECT [NON EMPTY] <axis_specification_list>
                      FROM <cube_specification>
                      [WHERE <slicer_specification>]
```

**Key Components:**

- **WITH Section** (optional): Defines calculated members and named sets
- **SELECT**: Core query keyword
- **NON EMPTY**: Optional modifier to exclude empty cells
- **Axis Specifications**: Define what appears on query axes
- **FROM**: Specifies the cube/database
- **WHERE**: Optional slicer to filter the query context

### 1.2 WITH Section

```bnf
<with_section> ::= WITH <with_formula_list>

<with_formula_list> ::= <with_formula> [<with_formula_list>]

<with_formula> ::= MEMBER <member_specification> AS <value_expression>
                 | SET <set_alias> AS <set_expression>
```

## 2. Axis Specifications

### 2.1 Axis Definition

```bnf
<axis_specification_list> ::= <axis_specification> [, <axis_specification_list>]

<axis_specification> ::= [NON EMPTY] <set_expression> ON <axis_name>

<axis_name> ::= COLUMNS | ROWS | PAGES | CHAPTERS | SECTIONS 
              | AXIS(<unsigned_integer>)
```

**Axis Aliases:**

- AXIS(0) = COLUMNS
- AXIS(1) = ROWS
- AXIS(2) = PAGES
- AXIS(3) = CHAPTERS
- AXIS(4) = SECTIONS
- Up to AXIS(63) supported

## 3. Set Specifications

### 3.1 Set Expressions

```bnf
<set_expression> ::= { <set_content> }
                   | <set_function>
                   | <set_alias>

<set_content> ::= <tuple_expression> [, <set_content>]
                | <member_expression> [, <set_content>]
                | <member_range>
```

### 3.2 Member Range

```bnf
<member_range> ::= <member_expression> : <member_expression>
```

## 4. Member Specifications

### 4.1 Member Expression

```bnf
<member_expression> ::= <member_identifier>
                      | <member_function>
                      | <calculated_member>

<member_identifier> ::= [<dimension_name>].[<member_name>]
                      | [<member_name>]
```

### 4.2 Member Naming Rules

- Members can be delimited with brackets: `[Member Name]`
- Dimension qualification: `[Dimension].[Member]`
- Support for duplicate member names and aliases
- Case sensitivity depends on database settings

## 5. Tuple Specifications

```bnf
<tuple_expression> ::= ( <member_expression_list> )

<member_expression_list> ::= <member_expression> [, <member_expression_list>]
```

**Rules:**

- A tuple represents a coordinate in multidimensional space
- Each dimension can appear at most once in a tuple
- Order of members in tuple doesn’t matter semantically

## 6. Cube Specification

```bnf
<cube_specification> ::= <cube_name>
                       | [<application_name>].[<database_name>]

<cube_name> ::= <identifier>
```

## 7. Functions

### 7.1 Set Functions

Common set-returning functions that need to be supported:

```bnf
<set_function> ::= Children(<member_expression>)
                 | Descendants(<member_expression>, <level_expression>)
                 | Members(<dimension_expression>)
                 | CrossJoin(<set_expression>, <set_expression>)
                 | Filter(<set_expression>, <logical_expression>)
                 | Union(<set_expression>, <set_expression>)
                 | Intersect(<set_expression>, <set_expression>)
                 | Except(<set_expression>, <set_expression>)
                 | MemberRange(<member_expression>, <member_expression>)
                 | NonEmptySubset(<set_expression>)
```

### 7.2 Member Functions

```bnf
<member_function> ::= Parent(<member_expression>)
                    | FirstChild(<member_expression>)
                    | LastChild(<member_expression>)
                    | Lead(<member_expression>, <numeric_expression>)
                    | Lag(<member_expression>, <numeric_expression>)
                    | NextMember(<member_expression>)
                    | PrevMember(<member_expression>)
```

### 7.3 Numeric Functions

```bnf
<numeric_function> ::= Count(<set_expression>)
                     | Sum(<set_expression>, <numeric_expression>)
                     | Avg(<set_expression>, <numeric_expression>)
                     | Max(<set_expression>, <numeric_expression>)
                     | Min(<set_expression>, <numeric_expression>)
```

## 8. Expressions

### 8.1 Value Expressions

```bnf
<value_expression> ::= <numeric_expression>
                     | <string_expression>
                     | <logical_expression>

<numeric_expression> ::= <number>
                       | <member_expression>
                       | <tuple_expression>
                       | <numeric_function>
                       | <numeric_expression> <arithmetic_operator> <numeric_expression>
                       | ( <numeric_expression> )

<arithmetic_operator> ::= + | - | * | /
```

### 8.2 Logical Expressions

```bnf
<logical_expression> ::= <comparison_expression>
                       | <logical_expression> AND <logical_expression>
                       | <logical_expression> OR <logical_expression>
                       | NOT <logical_expression>

<comparison_expression> ::= <numeric_expression> <comparison_operator> <numeric_expression>

<comparison_operator> ::= = | <> | < | > | <= | >=
```

## 9. Properties and Attributes

### 9.1 Member Properties

```bnf
<property_expression> ::= <member_expression>.Properties(<property_name>)

<property_name> ::= "MEMBER_NAME" | "MEMBER_CAPTION" | "LEVEL_NUMBER" 
                  | "GENERATION_NUMBER" | <user_defined_property>
```

## 10. Format Strings

```bnf
<format_string_expression> ::= MdxFormat(<string_value_expression>)
```

## 11. Special Constructs

### 11.1 Calculated Members

```bnf
MEMBER <dimension>.<member_name> AS <value_expression>
       [, <member_property_list>]

<member_property_list> ::= <member_property> [, <member_property_list>]

<member_property> ::= FORMAT_STRING = <string_expression>
                    | SOLVE_ORDER = <integer>
                    | VISIBLE = <boolean>
```

### 11.2 Named Sets

```bnf
SET <set_alias> AS <set_expression>
```

### 11.3 Cell Properties

```bnf
CELL PROPERTIES VALUE, FORMATTED_VALUE, FORMAT_STRING
```

## 12. Operators

### 12.1 Set Operators

- `:` (colon) - Range operator
- `*` - CrossJoin shorthand
- `+` - Union
- `-` - Except

### 12.2 Navigation Operators

- `.` (dot) - Member property/function access
- `&` - String concatenation

## 13. Comments and Literals

```bnf
<comment> ::= -- <text_until_end_of_line>
            | /* <text> */

<string_literal> ::= "<characters>" | '<characters>'

<numeric_literal> ::= <integer> | <decimal>

<identifier> ::= <undelimited_identifier> | [<delimited_identifier>]
```

## 14. Key Parsing Challenges for Necto Output

Based on the description of “spaghetti mess” from Necto SSAS cubes, the parser should handle:

1. **Redundant Parentheses**: Excessive nesting that doesn’t affect semantics
1. **Verbose Function Calls**: Long chains of navigation functions
1. **Duplicate Specifications**: Same members specified multiple times
1. **Complex Calculated Members**: Nested calculations with unclear dependencies
1. **Unnecessary CrossJoins**: Cartesian products that could be simplified
1. **Deeply Nested Sets**: Sets within sets that could be flattened

## 15. Parser Implementation Priorities

### Phase 1 - Core Parsing (High Priority)

1. Basic SELECT-FROM-WHERE structure
1. Set and tuple expressions
1. Member identifiers and qualification
1. Basic functions (Children, Members, CrossJoin)
1. Axis specifications

### Phase 2 - Advanced Features (Medium Priority)

1. WITH section (calculated members, named sets)
1. Complex functions (Filter, Descendants, etc.)
1. Expressions and operators
1. Properties and attributes
1. NON EMPTY handling

### Phase 3 - Optimization & Edge Cases (Lower Priority)

1. Format strings
1. Cell properties
1. Sub-selects
1. Advanced navigation functions
1. Substitution variables

## Notes for Implementation

1. **Lexical Analysis**: Need to handle brackets, dots, parentheses, operators
1. **Case Sensitivity**: Make configurable based on source system
1. **Whitespace**: MDX is generally whitespace-insensitive except in identifiers
1. **Error Recovery**: Important for handling malformed Necto output
1. **AST Design**: Should support easy transformation and optimization

This specification provides the foundation for building a comprehensive MDX parser that can handle the complexity of real-world MDX queries, especially those generated by tools like Necto.
