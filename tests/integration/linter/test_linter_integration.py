"""Integration tests for MDX linter with parser pipeline."""

import pytest
from lark import Tree, Token

from unmdx.linter import MDXLinter, LinterConfig, OptimizationLevel


class TestLinterIntegration:
    """Integration tests for the complete linter workflow."""
    
    @pytest.fixture
    def sample_necto_patterns(self):
        """Sample MDX patterns commonly generated by Necto."""
        return {
            "redundant_parentheses": Tree("query", [
                Tree("select_clause", [
                    Tree("parenthesized_expression", [
                        Tree("parenthesized_expression", [
                            Tree("parenthesized_expression", [
                                Tree("bracketed_identifier", [Token("IDENTIFIER", "Measures")])
                            ])
                        ])
                    ])
                ])
            ]),
            
            "simple_crossjoin": Tree("query", [
                Tree("function_call", [
                    Token("IDENTIFIER", "CROSSJOIN"),
                    Tree("argument", [
                        Tree("set_expression", [
                            Tree("bracketed_identifier", [Token("IDENTIFIER", "Country")])
                        ])
                    ]),
                    Tree("argument", [
                        Tree("set_expression", [
                            Tree("bracketed_identifier", [Token("IDENTIFIER", "Product")])
                        ])
                    ])
                ])
            ]),
            
            "duplicate_members": Tree("query", [
                Tree("set_expression", [
                    Tree("member_list", [
                        Tree("bracketed_identifier", [Token("IDENTIFIER", "USA")]),
                        Tree("bracketed_identifier", [Token("IDENTIFIER", "Canada")]),
                        Tree("bracketed_identifier", [Token("IDENTIFIER", "USA")])  # Duplicate
                    ])
                ])
            ])
        }
    
    def test_conservative_optimization_workflow(self, sample_necto_patterns):
        """Test complete workflow with conservative optimization."""
        config = LinterConfig(optimization_level=OptimizationLevel.CONSERVATIVE)
        linter = MDXLinter(config)
        
        # Test redundant parentheses removal
        tree = sample_necto_patterns["redundant_parentheses"]
        result_tree, report = linter.lint(tree)
        
        assert isinstance(result_tree, Tree)
        assert isinstance(report, dict) or hasattr(report, 'actions')  # LintReport
        assert report.optimization_level == OptimizationLevel.CONSERVATIVE
        
        # Should have some actions for parentheses removal
        if hasattr(report, 'actions'):
            parentheses_actions = [a for a in report.actions 
                                 if "parentheses" in a.description.lower()]
            assert len(parentheses_actions) >= 1
    
    def test_moderate_optimization_workflow(self, sample_necto_patterns):
        """Test complete workflow with moderate optimization."""
        config = LinterConfig(optimization_level=OptimizationLevel.MODERATE)
        linter = MDXLinter(config)
        
        # Test with a tree that has function optimization opportunities
        tree = sample_necto_patterns["redundant_parentheses"]
        result_tree, report = linter.lint(tree)
        
        assert isinstance(result_tree, Tree)
        assert report.optimization_level == OptimizationLevel.MODERATE
        
        # Should load more rules at moderate level
        rule_names = linter.get_available_rules()
        assert "function_optimizer" in rule_names
    
    def test_aggressive_optimization_workflow(self, sample_necto_patterns):
        """Test complete workflow with aggressive optimization."""
        config = LinterConfig(optimization_level=OptimizationLevel.AGGRESSIVE)
        linter = MDXLinter(config)
        
        tree = sample_necto_patterns["redundant_parentheses"]
        result_tree, report = linter.lint(tree)
        
        assert isinstance(result_tree, Tree)
        assert report.optimization_level == OptimizationLevel.AGGRESSIVE
        
        # Aggressive should enable all optimization features
        assert config.max_crossjoin_depth == 5
        assert config.optimize_calculated_members == True
        assert config.simplify_function_calls == True
    
    def test_multiple_patterns_optimization(self, sample_necto_patterns):
        """Test optimization of multiple problematic patterns in one query."""
        # Create a complex tree with multiple issues
        complex_tree = Tree("query", [
            Tree("select_clause", [
                # Redundant parentheses
                Tree("parenthesized_expression", [
                    Tree("bracketed_identifier", [Token("IDENTIFIER", "Measures")])
                ])
            ]),
            Tree("from_clause", [
                # CrossJoin that could be simplified
                Tree("function_call", [
                    Token("IDENTIFIER", "CROSSJOIN"),
                    Tree("argument", [Tree("identifier", [Token("IDENTIFIER", "A")])]),
                    Tree("argument", [Tree("identifier", [Token("IDENTIFIER", "B")])])
                ])
            ])
        ])
        
        config = LinterConfig(optimization_level=OptimizationLevel.MODERATE)
        linter = MDXLinter(config)
        
        result_tree, report = linter.lint(complex_tree)
        
        assert isinstance(result_tree, Tree)
        
        # Should have applied multiple types of optimizations
        if hasattr(report, 'actions') and len(report.actions) > 0:
            action_types = {action.action_type for action in report.actions}
            # Might have both parentheses and crossjoin optimizations
            assert len(action_types) >= 1
    
    def test_optimization_report_generation(self, sample_necto_patterns):
        """Test that comprehensive optimization reports are generated."""
        config = LinterConfig(
            optimization_level=OptimizationLevel.MODERATE,
            generate_optimization_report=True
        )
        linter = MDXLinter(config)
        
        tree = sample_necto_patterns["redundant_parentheses"]
        source_mdx = "SELECT (([Measures].[Sales])) ON COLUMNS FROM [Sales]"
        
        result_tree, report = linter.lint(tree, source_mdx)
        
        # Check report completeness
        assert report.original_size == len(source_mdx)
        assert report.optimized_size >= 0
        assert report.duration_ms is not None
        assert report.start_time is not None
        assert report.end_time is not None
        
        # Check report methods
        summary = report.summary()
        assert "MDX Linting Report" in summary
        assert "moderate" in summary.lower()
        
        if len(report.actions) > 0:
            assert "Actions Performed" in summary
    
    def test_error_handling_and_recovery(self):
        """Test linter error handling with malformed trees."""
        config = LinterConfig(
            optimization_level=OptimizationLevel.CONSERVATIVE,
            skip_on_validation_error=True
        )
        linter = MDXLinter(config)
        
        # Create a potentially problematic tree
        problematic_tree = Tree("query", [
            None,  # Invalid child
            Tree("invalid_node", ["bad_data"])
        ])
        
        # Should not raise exception
        result_tree, report = linter.lint(problematic_tree)
        
        assert isinstance(result_tree, Tree)
        assert isinstance(report, dict) or hasattr(report, 'errors')
        
        # May have recorded errors
        if hasattr(report, 'errors'):
            # Errors might be recorded, but processing should continue
            assert isinstance(report.errors, list)
    
    def test_performance_with_large_trees(self):
        """Test linter performance with large MDX trees."""
        config = LinterConfig(
            optimization_level=OptimizationLevel.CONSERVATIVE,
            max_processing_time_ms=5000  # 5 second timeout
        )
        linter = MDXLinter(config)
        
        # Create a large tree with many nodes
        large_tree = Tree("query", [
            Tree("select_clause", [
                Tree("parenthesized_expression", [
                    Tree("identifier", [Token("IDENTIFIER", f"Measure{i}")])
                ]) for i in range(50)  # 50 redundant parentheses
            ])
        ])
        
        result_tree, report = linter.lint(large_tree)
        
        assert isinstance(result_tree, Tree)
        
        # Should complete within timeout
        if hasattr(report, 'duration_ms') and report.duration_ms:
            assert report.duration_ms < 5000
    
    def test_rule_interaction_and_ordering(self, sample_necto_patterns):
        """Test that rules interact correctly and are applied in proper order."""
        config = LinterConfig(optimization_level=OptimizationLevel.MODERATE)
        linter = MDXLinter(config)
        
        # Create tree that could benefit from multiple rules
        complex_tree = Tree("query", [
            Tree("with_clause", [
                # Duplicate calculated members
                Tree("calculated_member", [
                    Tree("member_name", [Token("IDENTIFIER", "TestMember")]),
                    Tree("expression", [Tree("identifier", [Token("IDENTIFIER", "Value")])])
                ]),
                Tree("calculated_member", [
                    Tree("member_name", [Token("IDENTIFIER", "TestMember")]),  # Duplicate
                    Tree("expression", [Tree("identifier", [Token("IDENTIFIER", "Value")])])
                ])
            ]),
            Tree("select_clause", [
                # Redundant parentheses
                Tree("parenthesized_expression", [
                    Tree("identifier", [Token("IDENTIFIER", "Measures")])
                ])
            ])
        ])
        
        result_tree, report = linter.lint(complex_tree)
        
        assert isinstance(result_tree, Tree)
        
        # Rules should be applied in proper order
        if hasattr(report, 'rules_applied'):
            # Should have applied multiple rules
            assert len(report.rules_applied) >= 1
    
    def test_optimization_level_impact(self, sample_necto_patterns):
        """Test that different optimization levels produce different results."""
        tree = sample_necto_patterns["redundant_parentheses"]
        
        # Test all optimization levels
        configs = [
            LinterConfig(optimization_level=OptimizationLevel.CONSERVATIVE),
            LinterConfig(optimization_level=OptimizationLevel.MODERATE),
            LinterConfig(optimization_level=OptimizationLevel.AGGRESSIVE)
        ]
        
        results = []
        for config in configs:
            linter = MDXLinter(config)
            result_tree, report = linter.lint(tree)
            results.append((result_tree, report, linter.get_available_rules()))
        
        # Should have different numbers of available rules
        conservative_rules = set(results[0][2])
        moderate_rules = set(results[1][2])
        aggressive_rules = set(results[2][2])
        
        # Moderate should have at least as many rules as conservative
        assert len(moderate_rules) >= len(conservative_rules)
        # Aggressive should have at least as many rules as moderate
        assert len(aggressive_rules) >= len(moderate_rules)
    
    def test_custom_rule_configuration(self):
        """Test custom rule enabling/disabling."""
        # Disable specific rules
        config = LinterConfig(
            optimization_level=OptimizationLevel.MODERATE,
            disabled_rules=["function_optimizer"]
        )
        linter = MDXLinter(config)
        
        available_rules = linter.get_available_rules()
        
        # Should not include disabled rule
        assert "function_optimizer" not in available_rules
        # Should still include other rules
        assert "parentheses_cleaner" in available_rules
    
    def test_validation_settings_impact(self, sample_necto_patterns):
        """Test impact of validation settings on linter behavior."""
        tree = sample_necto_patterns["redundant_parentheses"]
        
        # Test with validation enabled
        config_with_validation = LinterConfig(
            optimization_level=OptimizationLevel.CONSERVATIVE,
            validate_before_optimizing=True,
            validate_after_optimizing=True
        )
        linter_with_validation = MDXLinter(config_with_validation)
        
        result_tree1, report1 = linter_with_validation.lint(tree)
        
        # Test with validation disabled
        config_no_validation = LinterConfig(
            optimization_level=OptimizationLevel.CONSERVATIVE,
            validate_before_optimizing=False,
            validate_after_optimizing=False
        )
        linter_no_validation = MDXLinter(config_no_validation)
        
        result_tree2, report2 = linter_no_validation.lint(tree)
        
        # Both should produce results
        assert isinstance(result_tree1, Tree)
        assert isinstance(result_tree2, Tree)
        
        # Validation settings shouldn't affect basic functionality
        # (though they might affect error handling)
        assert isinstance(report1, dict) or hasattr(report1, 'actions')
        assert isinstance(report2, dict) or hasattr(report2, 'actions')